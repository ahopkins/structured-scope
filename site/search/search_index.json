{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Structured Scopes Abstract This is an abstract specification for the use of structured scopes in permission granting utilities. Introduction The goal of this endeavor is to standardize and define the meaning, and usage of \"scopes\" for implementation in an authorization utility. It is licensed under the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication All other copyrights and other rights, if any, are hereby reserved. Purpose The purpose of \"scoping\" is to provide a pass/fail response to a request for permission on a defined resource to authorized clients having the requisite permission level. A common application would be for permissioning on protected resources, for example, on web requests. Brief Examples in brief: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Base : user Inbound : foobar Result : fail Base : user Inbound : user Result : pass Base : user : write Inbound : user Result : pass Base : user : write Inbound : user : read Result : fail See more examples Implementations Python - source | docs Javascript - source | docs","title":"Structured Scopes"},{"location":"#structured-scopes","text":"","title":"Structured Scopes"},{"location":"#abstract","text":"This is an abstract specification for the use of structured scopes in permission granting utilities.","title":"Abstract"},{"location":"#introduction","text":"The goal of this endeavor is to standardize and define the meaning, and usage of \"scopes\" for implementation in an authorization utility. It is licensed under the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication All other copyrights and other rights, if any, are hereby reserved.","title":"Introduction"},{"location":"#purpose","text":"The purpose of \"scoping\" is to provide a pass/fail response to a request for permission on a defined resource to authorized clients having the requisite permission level. A common application would be for permissioning on protected resources, for example, on web requests.","title":"Purpose"},{"location":"#brief","text":"Examples in brief: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Base : user Inbound : foobar Result : fail Base : user Inbound : user Result : pass Base : user : write Inbound : user Result : pass Base : user : write Inbound : user : read Result : fail See more examples","title":"Brief"},{"location":"#implementations","text":"Python - source | docs Javascript - source | docs","title":"Implementations"},{"location":"acceptance/","text":"General The pattern for acceptance is that a client offers an \"inbound\" scope to an authorizing agent and requests acceptance. That authorizing agent has a predefined \"base\" scope. The role of the authorizing agent is to match the inbound against the base and produce a pass / fail result. Base The base can be any valid scope, including negations. Inbounds Inbounds may not contain negations ( :: ). And, if they do, the authorizing agent should produce an error without providing a pass / fail result. How scopes are matched An inbound shall pass against a given base if: The namespace of the inbound is equal to the namespace of the base, except a global namespace matches every other namespace, and an empty namespace is unmatchable . If the base has a defined action, or actions, then the inbound must: be a top level scope with no defined actions, or contain all of the same actions as the base* If the base does NOT have a defined action (and therefore is top level), then the inbound must be a top level scope also. Note An implementation of this specification may offer a validation mechanism that only requires one action to match Multiple scopes Scopes can be chained together as a single string separated by a space: 1 admin user:read ::delete Where there are multiple scopes, the order in which they appear shall have no importance and shall not play a part in the acceptance of the inbound. A validation of multiple scopes is valid if the inbound matches all of the base scopes. * Note An implementation of this specification may offer a validation mechanism that only requires one inbound to match the base","title":"Acceptance"},{"location":"acceptance/#general","text":"The pattern for acceptance is that a client offers an \"inbound\" scope to an authorizing agent and requests acceptance. That authorizing agent has a predefined \"base\" scope. The role of the authorizing agent is to match the inbound against the base and produce a pass / fail result.","title":"General"},{"location":"acceptance/#base","text":"The base can be any valid scope, including negations.","title":"Base"},{"location":"acceptance/#inbounds","text":"Inbounds may not contain negations ( :: ). And, if they do, the authorizing agent should produce an error without providing a pass / fail result.","title":"Inbounds"},{"location":"acceptance/#how-scopes-are-matched","text":"An inbound shall pass against a given base if: The namespace of the inbound is equal to the namespace of the base, except a global namespace matches every other namespace, and an empty namespace is unmatchable . If the base has a defined action, or actions, then the inbound must: be a top level scope with no defined actions, or contain all of the same actions as the base* If the base does NOT have a defined action (and therefore is top level), then the inbound must be a top level scope also. Note An implementation of this specification may offer a validation mechanism that only requires one action to match","title":"How scopes are matched"},{"location":"acceptance/#multiple-scopes","text":"Scopes can be chained together as a single string separated by a space: 1 admin user:read ::delete Where there are multiple scopes, the order in which they appear shall have no importance and shall not play a part in the acceptance of the inbound. A validation of multiple scopes is valid if the inbound matches all of the base scopes. * Note An implementation of this specification may offer a validation mechanism that only requires one inbound to match the base","title":"Multiple scopes"},{"location":"examples/","text":"Examples of scopes Valid Scopes admin user:read user:read:write :read :read:write : :: user:write:delete::read (a blank space) Structured Scopes test cases Simple single scopes - specific namespace Base scope Inbound scope Expected outcome user something fail user user pass user user:read fail user:read user pass user:read user:read pass user:read user:write fail user:read user:read:write pass user:read:write user:read fail* user:read:write user:read:write pass user:read:write user:write:read pass user: user pass user: user:read pass user: user:write pass Simple single scopes - global namespace Base scope Inbound scope Expected outcome : :read pass : admin pass : anything here pass :read admin pass :read :read pass :read :write fail global: :read pass global: admin pass global: anything here pass global:read admin pass global:read :read pass global:read :write fail global :read fail global admin pass user:write global:write fail user:write :write fail admin global fail Simple multiple scopes Base scope Inbound scope Expected outcome user something else fail user something else user pass user:read something:else user:read pass user:read user:read something:else pass user foo user fail** user foo user foo pass user foo foo user pass user:read foo user foo pass user:read foo user foo:read fail user:read foo user:read foo pass user:read foo:bar :read:bar fail user:read foo:bar user:read foo pass user:read foo:bar user foo pass user foo user fail* Complex scopes Base scope Inbound scope Expected outcome ::delete user pass ::delete user:read fail ::delete user:delete fail ::delete user:read:delete fail :::delete user pass :::delete user:read fail :::delete user:delete fail :::delete user:read:delete fail user::delete user pass user::delete user:read fail user::delete user:delete fail user::delete user:read:delete fail user:::delete user pass user:::delete user:read fail user:::delete user:delete fail user:::delete user:read:delete fail user:read::delete user pass user:read::delete user:read pass user:read::delete user:delete fail user:read::delete user:read:delete fail user:read::delete user:write fail user:read user::delete user:read:delete fail** user:read user::delete user:read user:delete fail** anything here fail :: anything here fail Note The preferred method of failing any scope should be :: and not an empty space for its explicit nature. 1 2 3 Legend * This is the default outcome. However, the validator should be capable of receiving an instruction that instead of ALL actions being required, only one must match. ** This is the default outcome. However, the validator should be capable of receiving an instruction that instead of ALL required scopes being met, only ONE required scope is fulfilled.","title":"Examples"},{"location":"examples/#examples-of-scopes","text":"","title":"Examples of scopes"},{"location":"examples/#valid-scopes","text":"admin user:read user:read:write :read :read:write : :: user:write:delete::read (a blank space)","title":"Valid Scopes"},{"location":"examples/#structured-scopes-test-cases","text":"","title":"Structured Scopes test cases"},{"location":"examples/#simple-single-scopes-specific-namespace","text":"Base scope Inbound scope Expected outcome user something fail user user pass user user:read fail user:read user pass user:read user:read pass user:read user:write fail user:read user:read:write pass user:read:write user:read fail* user:read:write user:read:write pass user:read:write user:write:read pass user: user pass user: user:read pass user: user:write pass","title":"Simple single scopes - specific namespace"},{"location":"examples/#simple-single-scopes-global-namespace","text":"Base scope Inbound scope Expected outcome : :read pass : admin pass : anything here pass :read admin pass :read :read pass :read :write fail global: :read pass global: admin pass global: anything here pass global:read admin pass global:read :read pass global:read :write fail global :read fail global admin pass user:write global:write fail user:write :write fail admin global fail","title":"Simple single scopes - global namespace"},{"location":"examples/#simple-multiple-scopes","text":"Base scope Inbound scope Expected outcome user something else fail user something else user pass user:read something:else user:read pass user:read user:read something:else pass user foo user fail** user foo user foo pass user foo foo user pass user:read foo user foo pass user:read foo user foo:read fail user:read foo user:read foo pass user:read foo:bar :read:bar fail user:read foo:bar user:read foo pass user:read foo:bar user foo pass user foo user fail*","title":"Simple multiple scopes"},{"location":"examples/#complex-scopes","text":"Base scope Inbound scope Expected outcome ::delete user pass ::delete user:read fail ::delete user:delete fail ::delete user:read:delete fail :::delete user pass :::delete user:read fail :::delete user:delete fail :::delete user:read:delete fail user::delete user pass user::delete user:read fail user::delete user:delete fail user::delete user:read:delete fail user:::delete user pass user:::delete user:read fail user:::delete user:delete fail user:::delete user:read:delete fail user:read::delete user pass user:read::delete user:read pass user:read::delete user:delete fail user:read::delete user:read:delete fail user:read::delete user:write fail user:read user::delete user:read:delete fail** user:read user::delete user:read user:delete fail** anything here fail :: anything here fail Note The preferred method of failing any scope should be :: and not an empty space for its explicit nature. 1 2 3 Legend * This is the default outcome. However, the validator should be capable of receiving an instruction that instead of ALL actions being required, only one must match. ** This is the default outcome. However, the validator should be capable of receiving an instruction that instead of ALL required scopes being met, only ONE required scope is fulfilled.","title":"Complex scopes"},{"location":"implementations/","text":"There are currently two known implementations of Structured Scopes Python - source Javascript - source Both of them have a very similar API. Installation To get started install from your language's package manager. Python 1 pip install sscopes Javascript 1 npm install sscopes Acceptance The package has a single callable function that processes acceptance and returns a BOOLEAN value: validate() . Python 1 2 3 4 5 from sscopes import validate is_valid = validate ( \"user\" , \"user\" ) print ( is_valid ) # True Javascript 1 2 3 4 5 import validate from 'sscopes' ; const isValid = validate ( \"user\" , \"user\" ); console . log ( isValid ); # true Parameters The validate function accepts two required parameters, and three optional. base_scopes - REQUIRED The base scopes to be tested against inbounds - REQUIRED The inbound scopes to be accepted or rejected require_all - Whether all base scopes must be present, or just one, default TRUE require_all_actions - Whether all actions must be present, or just one, default TRUE override - A callable that will override the acceptance algorithm Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from sscopes import validate is_valid = validate ( \"user foobar\" , \"user\" ) print ( is_valid ) # False is_valid = validate ( \"user foobar\" , \"user\" , require_all = False ) print ( is_valid ) # True is_valid = validate ( \"user:write:read\" , \"user:write\" ) print ( is_valid ) # False is_valid = validate ( \"user:write:read\" , \"user:write\" , require_all_actions = False ) print ( is_valid ) # True Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import validate from 'sscopes' ; const isValid = validate ( \"user foobar\" , \"user\" ); console . log ( isValid ); # false const isValid = validate ( \"user foobar\" , \"user\" , false ); console . log ( isValid ); # true const isValid = validate ( \"user:write:read\" , \"user:write\" ); console . log ( isValid ); # false const isValid = validate ( \"user:write:read\" , \"user:write\" , true , false ); console . log ( isValid ); # true Override/Extend Somethimes, you may decide that the predefined logic of Structured Scopes is not enough, and you need to extend it. No problem, simple pass validate() a callable function. Note that the callable will receive the following parameters: is_valid - Whether the standard logic would accept the inbound scope or not base - The current base scope being tested inbounds - All current inbound scope(s) require_all_actions - The state of require_all_actions for validate Important It is important to note that the override callable is called one time for each base scope that was passed to validate . Therefore, if the base scope was one two three , it will be called three separate times. Python 1 2 3 4 5 6 7 8 from sscopes import validate def always_true ( is_valid , base , inbounds , require_all_actions ): return True is_valid = validate ( \"user foobar\" , \"user\" , override = always_true ) print ( is_valid ) # True Javascript 1 2 3 4 5 6 7 8 9 import validate from 'sscopes' ; const alwaysTrue = ( is_valid , base , inbounds , require_all_actions ) => { return true ; } const isValid = validate ( \"user foobar\" , \"user\" , true , true , alwaysTrue ); console . log ( isValid ); # true","title":"Implementations"},{"location":"implementations/#installation","text":"To get started install from your language's package manager. Python 1 pip install sscopes Javascript 1 npm install sscopes","title":"Installation"},{"location":"implementations/#acceptance","text":"The package has a single callable function that processes acceptance and returns a BOOLEAN value: validate() . Python 1 2 3 4 5 from sscopes import validate is_valid = validate ( \"user\" , \"user\" ) print ( is_valid ) # True Javascript 1 2 3 4 5 import validate from 'sscopes' ; const isValid = validate ( \"user\" , \"user\" ); console . log ( isValid ); # true","title":"Acceptance"},{"location":"implementations/#parameters","text":"The validate function accepts two required parameters, and three optional. base_scopes - REQUIRED The base scopes to be tested against inbounds - REQUIRED The inbound scopes to be accepted or rejected require_all - Whether all base scopes must be present, or just one, default TRUE require_all_actions - Whether all actions must be present, or just one, default TRUE override - A callable that will override the acceptance algorithm Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from sscopes import validate is_valid = validate ( \"user foobar\" , \"user\" ) print ( is_valid ) # False is_valid = validate ( \"user foobar\" , \"user\" , require_all = False ) print ( is_valid ) # True is_valid = validate ( \"user:write:read\" , \"user:write\" ) print ( is_valid ) # False is_valid = validate ( \"user:write:read\" , \"user:write\" , require_all_actions = False ) print ( is_valid ) # True Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import validate from 'sscopes' ; const isValid = validate ( \"user foobar\" , \"user\" ); console . log ( isValid ); # false const isValid = validate ( \"user foobar\" , \"user\" , false ); console . log ( isValid ); # true const isValid = validate ( \"user:write:read\" , \"user:write\" ); console . log ( isValid ); # false const isValid = validate ( \"user:write:read\" , \"user:write\" , true , false ); console . log ( isValid ); # true","title":"Parameters"},{"location":"implementations/#overrideextend","text":"Somethimes, you may decide that the predefined logic of Structured Scopes is not enough, and you need to extend it. No problem, simple pass validate() a callable function. Note that the callable will receive the following parameters: is_valid - Whether the standard logic would accept the inbound scope or not base - The current base scope being tested inbounds - All current inbound scope(s) require_all_actions - The state of require_all_actions for validate Important It is important to note that the override callable is called one time for each base scope that was passed to validate . Therefore, if the base scope was one two three , it will be called three separate times. Python 1 2 3 4 5 6 7 8 from sscopes import validate def always_true ( is_valid , base , inbounds , require_all_actions ): return True is_valid = validate ( \"user foobar\" , \"user\" , override = always_true ) print ( is_valid ) # True Javascript 1 2 3 4 5 6 7 8 9 import validate from 'sscopes' ; const alwaysTrue = ( is_valid , base , inbounds , require_all_actions ) => { return true ; } const isValid = validate ( \"user foobar\" , \"user\" , true , true , alwaysTrue ); console . log ( isValid ); # true","title":"Override/Extend"},{"location":"makeup/","text":"Makeup of a scope A scope is a string of characters encoded with UTF-8 consisting of characters acceptable by RFC 6749, Section 3.3 . A scope has two components: (1) a namespace, and (2) actions. A scope's components (including multiple actions) are delimited by a colon: : . A scope cannot be a null value, but should produce an invalid_scope error, as defined by RFC 6749, Section 4.1.2.1 . The requested scope is invalid, unknown, or malformed. Namespace Every scope must have zero or one namespace. A namespace can either be specific or global . If a namespace is global , then it will be matched by any requesting scope. A specific namespace can only be matched by requests carrying the same specific namespace. The absense of a namespace (as discussed below) will indicate that no match can be achieved on the namespace. This is not to be confused with a blank namespace, that will be inferred as being a global namespace (see below). Valid characters: any UTF-8 accepted by RFC 6749 except a color : , and a space . The first delimited part of a scope is the namespace. An undefined namespace is in the global namespace (eg : or :someaction both produce the global namespace.) Alternatively, global is a protected word, and explicitly defines the namespace for a scope as the global namespace , example: global: . The global namespace is only available for base scopes and not for inbound scopes. Possible namespaces: foo = foo as a Specific namespace global = Global namespace (explicit) :read = Global namespace (inferred) : = Global namespace (inferred) = Empty string, NO namespace (ie, nothing can match) Actions A scope may have either zero or many actions. The actions are a narrowing focus of the namespace. A scope without any actions is said to be at the top level . Actions are anything that follows the first delimited part of the scope (the namespace) and are separated by : . Valid characters: any UTF-8 accepted by RFC 6749 except a colon : , and a space . Anything that follows any empty action (which is displayed as a double color: :: ) is a negative action, or a negation, for example ::exclusion . A negative action only impacts a specifically defined action, and has no impact upon (for example) a top level action. See below for discussion on matching. Negative actions are only permissible in base scopes, and not in inbound scopes. If an inbound scope contains a negation ( :: ), then it should raise an error. Where there are multiple actions, the order that they appear in shall have no consequence upon acceptance. Possible actions on a scope: foo = Top level :read:write = Multiple actions, namely read and write : = Any action, wildcard foo: = Any action, wildcard ::read:write = Any action except read and write","title":"Makeup"},{"location":"makeup/#makeup-of-a-scope","text":"A scope is a string of characters encoded with UTF-8 consisting of characters acceptable by RFC 6749, Section 3.3 . A scope has two components: (1) a namespace, and (2) actions. A scope's components (including multiple actions) are delimited by a colon: : . A scope cannot be a null value, but should produce an invalid_scope error, as defined by RFC 6749, Section 4.1.2.1 . The requested scope is invalid, unknown, or malformed.","title":"Makeup of a scope"},{"location":"makeup/#namespace","text":"Every scope must have zero or one namespace. A namespace can either be specific or global . If a namespace is global , then it will be matched by any requesting scope. A specific namespace can only be matched by requests carrying the same specific namespace. The absense of a namespace (as discussed below) will indicate that no match can be achieved on the namespace. This is not to be confused with a blank namespace, that will be inferred as being a global namespace (see below). Valid characters: any UTF-8 accepted by RFC 6749 except a color : , and a space . The first delimited part of a scope is the namespace. An undefined namespace is in the global namespace (eg : or :someaction both produce the global namespace.) Alternatively, global is a protected word, and explicitly defines the namespace for a scope as the global namespace , example: global: . The global namespace is only available for base scopes and not for inbound scopes. Possible namespaces: foo = foo as a Specific namespace global = Global namespace (explicit) :read = Global namespace (inferred) : = Global namespace (inferred) = Empty string, NO namespace (ie, nothing can match)","title":"Namespace"},{"location":"makeup/#actions","text":"A scope may have either zero or many actions. The actions are a narrowing focus of the namespace. A scope without any actions is said to be at the top level . Actions are anything that follows the first delimited part of the scope (the namespace) and are separated by : . Valid characters: any UTF-8 accepted by RFC 6749 except a colon : , and a space . Anything that follows any empty action (which is displayed as a double color: :: ) is a negative action, or a negation, for example ::exclusion . A negative action only impacts a specifically defined action, and has no impact upon (for example) a top level action. See below for discussion on matching. Negative actions are only permissible in base scopes, and not in inbound scopes. If an inbound scope contains a negation ( :: ), then it should raise an error. Where there are multiple actions, the order that they appear in shall have no consequence upon acceptance. Possible actions on a scope: foo = Top level :read:write = Multiple actions, namely read and write : = Any action, wildcard foo: = Any action, wildcard ::read:write = Any action except read and write","title":"Actions"}]}